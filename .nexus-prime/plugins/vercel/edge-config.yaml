# ═══════════════════════════════════════════════════════════════════════════════
#  NEXUS-PRIME: Vercel Edge Config Plugin
#  Ultra-low latency data store
# ═══════════════════════════════════════════════════════════════════════════════

plugin:
  id: "vercel-edge-config"
  name: "Vercel Edge Config"
  version: "1.0.0"
  description: "Ultra-low latency global data store for feature flags and configuration"
  team: "TEAM-VERCEL"
  agent: "EDGE-OPS"
  enabled: false  # Enable when needed

# Installation
installation:
  npm: "@vercel/edge-config"
  command: "npm install @vercel/edge-config"
  
  environment:
    - name: "EDGE_CONFIG"
      description: "Edge Config connection string"
      source: "Vercel Dashboard → Storage → Edge Config"

# Features
features:
  feature_flags:
    description: "Toggle features without redeploying"
    example: |
      import { get } from '@vercel/edge-config'
      
      // In middleware or edge function
      const showNewFeature = await get('showNewFeature')
      if (showNewFeature) {
        // Enable new feature
      }
  
  configuration:
    description: "Store app configuration"
    example: |
      import { get, getAll } from '@vercel/edge-config'
      
      // Get single value
      const apiLimit = await get('apiRateLimit')
      
      // Get all config
      const config = await getAll()
  
  ab_testing:
    description: "A/B test configuration"
    example: |
      import { get } from '@vercel/edge-config'
      
      const experiments = await get('experiments')
      // { "newCheckout": { "enabled": true, "percentage": 50 } }
  
  maintenance_mode:
    description: "Enable maintenance mode instantly"
    example: |
      // middleware.ts
      import { get } from '@vercel/edge-config'
      import { NextResponse } from 'next/server'
      
      export async function middleware() {
        const isMaintenanceMode = await get('maintenanceMode')
        
        if (isMaintenanceMode) {
          return NextResponse.rewrite(new URL('/maintenance', request.url))
        }
        
        return NextResponse.next()
      }

# Usage Templates
templates:
  middleware_feature_flag: |
    // middleware.ts
    import { get } from '@vercel/edge-config'
    import { NextResponse } from 'next/server'
    import type { NextRequest } from 'next/server'
    
    export async function middleware(request: NextRequest) {
      const featureFlags = await get('featureFlags')
      
      // Check if new dashboard is enabled
      if (featureFlags?.newDashboard && request.nextUrl.pathname === '/dashboard') {
        return NextResponse.rewrite(new URL('/dashboard-v2', request.url))
      }
      
      return NextResponse.next()
    }
    
    export const config = {
      matcher: ['/dashboard/:path*'],
    }
  
  api_route: |
    // app/api/config/route.ts
    import { get, getAll } from '@vercel/edge-config'
    
    export const runtime = 'edge'
    
    export async function GET() {
      const config = await getAll()
      
      return Response.json({
        featureFlags: config.featureFlags,
        limits: config.apiLimits,
      })
    }

# Best Practices
best_practices:
  - Use for frequently accessed, rarely changed data
  - Keep values small (max 64KB per item)
  - Use for feature flags, rate limits, redirects
  - Update via Dashboard or API (not at runtime)
  - Cache values when appropriate
