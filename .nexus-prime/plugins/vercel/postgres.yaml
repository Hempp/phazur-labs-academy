# ═══════════════════════════════════════════════════════════════════════════════
#  NEXUS-PRIME: Vercel Postgres Plugin
#  Serverless PostgreSQL database
# ═══════════════════════════════════════════════════════════════════════════════

plugin:
  id: "vercel-postgres"
  name: "Vercel Postgres"
  version: "1.0.0"
  description: "Serverless PostgreSQL with auto-scaling and edge compatibility"
  team: "TEAM-VERCEL"
  agent: "DEPLOY-MASTER"
  enabled: false  # Enable when needed

# Installation
installation:
  npm: "@vercel/postgres"
  command: "npm install @vercel/postgres"
  
  environment:
    - name: "POSTGRES_URL"
      description: "Primary database URL"
      source: "Auto-generated by Vercel"
    - name: "POSTGRES_URL_NON_POOLING"
      description: "Non-pooling connection for migrations"
      source: "Auto-generated by Vercel"
    - name: "POSTGRES_PRISMA_URL"
      description: "Prisma-compatible connection string"
      source: "Auto-generated by Vercel"

# Features
features:
  serverless:
    description: "Auto-scaling with pay-per-use"
  
  edge_compatible:
    description: "Works with Edge Runtime"
  
  connection_pooling:
    description: "Built-in connection pooling"
  
  sql_template_literals:
    description: "SQL injection protection"

# Usage Templates
templates:
  basic_query: |
    import { sql } from '@vercel/postgres'
    
    // Safe parameterized query
    const { rows } = await sql`
      SELECT * FROM users WHERE id = ${userId}
    `
    
    return rows[0]
  
  create_table: |
    import { sql } from '@vercel/postgres'
    
    await sql`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        name VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `
  
  insert: |
    import { sql } from '@vercel/postgres'
    
    const { rows } = await sql`
      INSERT INTO users (email, name)
      VALUES (${email}, ${name})
      RETURNING *
    `
    
    return rows[0]
  
  transaction: |
    import { db } from '@vercel/postgres'
    
    const client = await db.connect()
    
    try {
      await client.sql`BEGIN`
      await client.sql`INSERT INTO orders (user_id, total) VALUES (${userId}, ${total})`
      await client.sql`UPDATE users SET order_count = order_count + 1 WHERE id = ${userId}`
      await client.sql`COMMIT`
    } catch (e) {
      await client.sql`ROLLBACK`
      throw e
    } finally {
      client.release()
    }
  
  with_prisma: |
    // schema.prisma
    generator client {
      provider = "prisma-client-js"
    }
    
    datasource db {
      provider = "postgresql"
      url = env("POSTGRES_PRISMA_URL")
      directUrl = env("POSTGRES_URL_NON_POOLING")
    }
    
    model User {
      id        Int      @id @default(autoincrement())
      email     String   @unique
      name      String?
      createdAt DateTime @default(now())
    }
  
  api_route: |
    // app/api/users/route.ts
    import { sql } from '@vercel/postgres'
    import { NextResponse } from 'next/server'
    
    export async function GET() {
      const { rows } = await sql`SELECT * FROM users ORDER BY created_at DESC LIMIT 10`
      return NextResponse.json(rows)
    }
    
    export async function POST(request: Request) {
      const { email, name } = await request.json()
      
      const { rows } = await sql`
        INSERT INTO users (email, name)
        VALUES (${email}, ${name})
        RETURNING *
      `
      
      return NextResponse.json(rows[0], { status: 201 })
    }

# Best Practices
best_practices:
  - Always use parameterized queries (sql template literals)
  - Use connection pooling URL for app, non-pooling for migrations
  - Keep queries simple for edge functions
  - Use transactions for related operations
  - Index frequently queried columns
